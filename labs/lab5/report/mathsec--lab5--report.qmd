---
## Author
author:
  name: Магомед Асхабович Мажитов
  degrees: DSc
  orcid: 0000-0002-0877-7063
  email: 1032259381@rudn.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Лабораторная работа №5"
subtitle: "Вероятностные алгоритмы проверки чисел на простоту"
license: "CC BY"
---

# Цель работы

Цель работы - изучить и реализовать вероятностные алгоритмы проверки чисел на простоту.

# Задание

Реализовать вероятностные алгоритмы проверки чисел на простоту (тест Ферма, тест Соловэя-Штрассена, тест Миллера-Рабина) с помощью языка Julia.

# Теоретическое введение

Julia — высокоуровневый свободный язык программирования с динамической типизацией, созданный для математических вычислений[@julialang]. Эффективен также и для написания программ общего назначения. Синтаксис языка схож с синтаксисом других математических языков, однако имеет некоторые существенные отличия.

Для выполнения заданий была использована официальная документация Julia[@juliadoc].

# Выполнение лабораторной работы

## Тест Ферма

Тест Ферма — это вероятностный алгоритм проверки числа на простоту, основанный на малой теореме Ферма. Согласно теореме, если n — простое число и a — целое число, не делящееся на n, то a^(n-1) ≡ 1 (mod n). Алгоритм выбирает случайное число a из диапазона [2, n-2] и проверяет это условие. Если условие не выполняется, число составное. Если выполняется, число вероятно простое.

```julia
function test_ferma(n)
    if n < 5
        throw(ArgumentError("Число n должно быть больше или равно 5"))
    end
    a = rand(2:(n-2))
    r = powermod(a, n-1, n)
    if r == 1
        println("Число $n, вероятно, простое")
        return
    else
        println("Число $n составное")
        return
    end
end
```

## Символ Якоби

Символ Якоби — это обобщение символа Лежандра для составных модулей. Функция вычисляет символ Якоби (a/n), используя рекурсивный алгоритм с выделением степеней двойки и применением свойств квадратичной взаимности.

```julia
function symbol_jacobi(n, a)
    if n < 3
        throw(ArgumentError("Число n должно быть больше или равно 3"))
    end
    if !(a >= 0 && a < n)
        throw(ArgumentError("Число a должно быть в промежутке от 0 до n"))
    end

    g = 1
    a_current = a
    n_current = n

    while true
        if a_current == 0
            return 0
        end
        if a_current == 1
            return g
        end

        k = 0
        a1 = a_current
        s = 1

        while a1 % 2 == 0
            a1 ÷= 2
            k += 1
        end

        if k % 2 == 0
            s = 1
        else
            if abs(n_current) % 8 == 1
                s = 1
            elseif abs(n_current) % 8 == 3
                s = -1
            end
        end

        if a1 == 1
            return g * s
        end

        if n_current % 4 == 3 && a1 % 4 == 3
            s = -s
        end

        a_current = n_current % a1
        n_current = a1
        g = g * s
    end
end
```

## Тест Соловэя-Штрассена

Тест Соловэя-Штрассена — это вероятностный тест простоты, который использует символ Якоби. Для простого числа n и случайного a выполняется условие: a^((n-1)/2) ≡ (a/n) (mod n), где (a/n) — символ Якоби. Если условие не выполняется, число составное.

```julia
function solovei_shtrassen(n)
    if n < 5
        throw(ArgumentError("Число n должно быть больше или равно 5"))
    end

    a = rand(2:(n-2))
    jacobi = symbol_jacobi(n, a)

    if jacobi == 0
        println("Число $n составное")
        return
    end

    exp = (n - 1) ÷ 2
    r = powermod(a, exp, n)

    if r == (jacobi % n)
        println("Число $n, вероятно, простое")
        return
    end

    println("Число $n составное")
end
```

## Тест Миллера-Рабина

Тест Миллера-Рабина — это один из наиболее эффективных вероятностных тестов простоты. Алгоритм основан на представлении n-1 = 2^s · r, где r — нечетное число. Для случайного a проверяется последовательность степеней: a^r, a^(2r), a^(4r), ..., a^(2^(s-1)·r) по модулю n. Число простое, если a^r ≡ 1 (mod n) или существует i такое, что a^(2^i·r) ≡ -1 (mod n).

```julia
function miller_rabin(n)
    if n < 5
        throw(ArgumentError("Число n должно быть больше или равно 5"))
    end

    r = n - 1
    s = 0
    while r % 2 == 0
        r ÷= 2
        s += 1
    end

    a = rand(2:(n-2))
    y = powermod(a, r, n)

    if y != 1 && y != n-1
        j = 1
        while j < s && y != n-1
            y = powermod(y, 2, n)
            if y == 1
                println("Число $n составное")
                return
            end
            j += 1
        end

        if y != n-1
            println("Число $n составное")
            return
        end
    end

    println("Число $n, вероятно, простое")
end
```

Для вывода результата используем функцию main.

```julia
function main()
    println("Тест Ферма")
    test_ferma(11)
    test_ferma(15)
    println("Тест Соловэя-Штрассена")
    solovei_shtrassen(11)
    solovei_shtrassen(15)
    println("Тест Миллера-Рабина")
    miller_rabin(11)
    miller_rabin(15)
end
```

Результат работы программы ([рис. @fig-001]).

![Результат](image/res.png){#fig-001 width=70%}

# Выводы

С помощью языка программирования Julia были реализованы вероятностные алгоритмы проверки чисел на простоту: тест Ферма, тест Соловэя-Штрассена и тест Миллера-Рабина.

# Список литературы{.unnumbered}

::: {#refs}
:::
